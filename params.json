{"name":"Autojsoncxx","tagline":"A header-only library and a code generator to automatically translate between JSON and C++ types","body":"# autojsoncxx\r\n\r\nA header-only library and a code generator to **automagically** translate between **JSON** and **C++** types.\r\n\r\n## Overview\r\n\r\nJSON is an excellent format for data serialization due to its simplicity, flexibility, portability and human-readable nature. Writing code to parse and generate JSON, however, is not an easy task in a statically typed language. Even with the help of JSON libraries, you need to write a lot of boilerplate code, and convoluted ones if you need to enforce the static typing of C++.\r\n\r\nMore importantly, maually writing the code means duplication of effort, and duplication is bad for programmers. When your client or PM request a change in feature, many classes (like the class responsible for configuration) will likely change, and you will have to rewrite the code. During the rewrite, time is wasted, people become impatient, and bugs may be introduced when the class definition, parsing and serialization code become out of sync.\r\n\r\n*autojsoncxx* is an attempt to solve this problem by automating such process. It is currently still in beta stage, so expect things to change in the future.\r\n\r\n### Dependency \r\n\r\n* [RapidJSON](https://github.com/miloyip/rapidjson) \r\n* (optional) [Parsimonious](https://github.com/erikrose/parsimonious)\r\n* (optional) [Catch](https://github.com/philsquared/Catch)\r\n* (optional) [Boost](http://www.boost.org)\r\n\r\n## Features\r\n\r\n* The parsing/serializing code are **automagically** generated. You don't even need to understand what is proper JSON to use it, although it may help you diagnose problems.\r\n* **Detailed error message**. Not only do you get informed if the JSON is not valid, but you will have a verbose trace back pointing to the location of the problem as well, if the JSON value does not fit your class structure.\r\n* **Ease of use**. Many convience functions are added so that a single function call is enough for most use cases. The library as well as its dependency are header only, while the code generator depends only on standard library of Python 3, so no complicated setup for your build system is needed.\r\n* **Fast**. The underlying JSON engine (RapidJSON) has been benchmarked to be about an order of magnitude faster than other popular JSON libraries. Besides, this library uses its SAX API, obviating the need of constructing a Document Object Model as the intermediate representation. Lastly, the library utilizes C++ templates to generate the algorithm at compile time, so no overhead of runtime indirection (except when error occurs).\r\n* **Flexible framework**. You can add more type support to the library by specializing certain template classes. In addition, whenever a class is generated, you can also parse/serialize an array of such class, a nullable wrapper of such class, another class that contains it, etc.\r\n* **Liberal licence**. Both the library and its dependency are licenced liberally (MIT or BSD-like). Anyone is free to copy, distribute, modify or include in their own projects, be it open source or commercial.\r\n\r\n## Testing\r\n\r\n[![Build Status](https://travis-ci.org/netheril96/autojsoncxx.svg?branch=master)](https://travis-ci.org/netheril96/autojsoncxx)\r\n\r\nTo build the test, you need a sufficiently new compiler because the goal is to test all the type support, including many ones only introduced in c++11.\r\n\r\nFirst clone the repository, and pull the dependency\r\n\r\n```bash\r\ngit clone https://github.com/netheril96/autojsoncxx.git\r\ngit submodule init\r\ngit submodule update\r\n```\r\n\r\n*UNIX/Linux/Mac users*:\r\n\r\n```bash\r\nmake\r\nmake test\r\n```\r\n\r\n*Windows users*: \r\n\r\nGenerate the `test/userdef.hpp` file from the definition `examples/userdef.json`. Then open the solution file under `test/mscvXX_test/` to build and run the test.\r\n\r\nIf too many tests fail, make sure your work directory points to the `test` directory.\r\n\r\n### Currently tested compilers\r\n\r\n* Clang 3.4 on Mac OS X (11.9)\r\n* GCC 4.9 (Homebrew) on Mac OS X (11.9)\r\n* Clang 3.0 on Ubuntu 12.04 (x64)\r\n* GCC 4.8 on Ubuntu 14.04.1 (x86/x64)\r\n* MSVC 10 (x86) on Windows 7\r\n* MSVC 11/12 (x86/x64) on Windows 7\r\n\r\n## First example\r\n\r\nThe code generator reads a JSON file that defines the class structure. An example definition is like this (remember to fully qualify the type name with its namespace)\r\n\r\n```javascript\r\n{\r\n    \"name\": \"Person\",\r\n    \"members\":\r\n    [\r\n        [\"unsigned long long\", \"ID\", {\"required\": true}],\r\n        [\"std::string\", \"name\", {\"default\": \"anonymous\"}],\r\n        [\"double\", \"height\"],\r\n        [\"double\", \"weight\"],\r\n        [\"std::vector<unsigned long long>\", \"known_associates\"]\r\n    ]\r\n}\r\n```\r\n\r\nRun the script *autojsoncxx.py* (requires Python 3) on this definition file, and a header file will be generated. It includes a definition for `Person` as well as some helper classes. The `Person` is a `struct` with all members public, meant as a data holder without any additional functionalities. It can be used with free functions, or [wrapped up in another class to provide encapsulation and polymorphism](https://en.wikipedia.org/wiki/Composition_over_inheritance).\r\n\r\n```bash\r\npython3 autojsoncxx.py --input=persondef.json --output=person.hpp\r\n```\r\n\r\nRemember to add the include directory of *autojsoncxx* and *rapidjson* to your project header search path (no linking is required). \r\n\r\nThe below examples uses c++11 features, but the library should also work with c++03 compilers.\r\n\r\n(There is now also support for using `libclang` to *directly* parse C++ source, without JSON definition file at all. However, given that the API of `clang` changes so frequently without regards about backwards compatibility, it is not recommended for the faint of heart. See branch `clang` for details.)\r\n\r\n### Serialization\r\n\r\n```c++\r\n#define AUTOJSONCXX_MODERN_COMPILER 1 // Turn on all the c++11 features of the library\r\n#include <iostream>\r\n#include \"person.hpp\"\r\n\r\nint main()\r\n{\r\n    Person p;\r\n    p.name = \"Mike\";\r\n    p.ID = 8940220481904ULL;\r\n    p.weight = 70;\r\n    p.height = 1.77;\r\n    p.known_associates = { 149977889346362, 90000134866608, 44412567664 };\r\n    // Use successive push_back() if your compiler is not c++11 ready\r\n\r\n    autojsoncxx::to_pretty_json_file(\"person.json\", p);\r\n    return 0;\r\n}\r\n```\r\n\r\nThis will generate a file `person.json` with contents below:\r\n\r\n```javascript\r\n{\r\n    \"name\": \"Mike\",\r\n    \"ID\": 8940220481904,\r\n    \"height\": 1.77,\r\n    \"weight\": 70.0,\r\n    \"known_associates\": [\r\n        149977889346362,\r\n        90000134866608,\r\n        44412567664\r\n    ]\r\n}\r\n```\r\n\r\n### Parsing\r\nNow let's try read that back\r\n\r\n```c++\r\n#define AUTOJSONCXX_MODERN_COMPILER 1\r\n#include <iostream>\r\n#include \"person.hpp\"\r\n\r\nint main()\r\n{\r\n    autojsoncxx::ParsingResult result;\r\n    Person p;\r\n    if (!autojsoncxx::from_json_file(\"person.json\", p, result)) {\r\n        std::cerr << result << '\\n';\r\n        return -1;\r\n    }\r\n\r\n    std::cout << \"ID: \" << p.ID << '\\n'\r\n              << \"name:  \" << p.name << '\\n'\r\n              << \"height: \" << p.height << '\\n'\r\n              << \"weight: \" << p.weight << '\\n';\r\n\r\n    std::cout << \"known associates: \";\r\n    for (auto&& id : p.known_associates)\r\n        std::cout << id << '\\t';\r\n    std::cout << '\\n';\r\n    return 0;\r\n}\r\n```\r\n\r\n### Error handling\r\n\r\nIf the JSON file is malformed, any decent JSON library will detect it and tell you what goes wrong. But what if the JSON value is perfectly valid, but not layed out the way you expected? Usually you have to manually check the DOM tree against your specification, but this library will automatically generates the necessary code.\r\n\r\nHere is valid JSON file\r\n\r\n```javascript\r\n{\r\n    \"name\": \"Mike\",\r\n    \"ID\": 8940220481904,\r\n    \"height\": 1.77,\r\n    \"weight\": 70.0,\r\n    \"known_associates\": [\r\n        \"Jack\", \"Mary\"\r\n    ]\r\n}\r\n```\r\n\r\nRunning through the parsing code, and you will get an error output:\r\n\r\n```\r\nParsing failed at offset 127 with error code 16:\r\nTerminate parsing due to Handler error.\r\n\r\nTrace back (last call first):\r\n(*) Type mismatch between expected type \"uint64_t\" and actual type \"string\"\r\n(*) Error at array element with index 0\r\n(*) Error at object member with name \"known_associates\"\r\n```\r\n\r\nTo programmingly examine the error, you need to query the `autojsoncxx::ParsingResult` class. Call `error_code()` and `offset()` to examine it. When `error_code() == rapidjson::kParseErrorTermination`, you can also iterate over the `autojsoncxx::ParsingResult` object for any errors resulting from mapping JSON to C++ types; otherwise the error is a result of malformed JSON, such as missing coma, invalid escape sequence, etc.\r\n\r\n```c++\r\nif (!result.has_error())\r\n    return;\r\n\r\n// equivalent: if (result.error_stack().empty())\r\nif (result.error_code() != rapidjson::kParseErrorTermination)\r\n{\r\n    std::cerr << \"Malformed JSON: \" << result.short_description() << '\\n';\r\n    return;\r\n}\r\n\r\n// equivalent: for (auto&& e: result.error_stack())\r\nfor (auto&& e : result) {\r\n    using namespace autojsoncxx::error;\r\n\r\n    switch (e.type()) {\r\n    \r\n    case UNKNOWN_FIELD: {\r\n        const UnknownFieldError& err = static_cast<const UnknownFieldError&>(e);\r\n        if (err.field_name().find(\"Version\") != std::string::npos)\r\n            std::cerr << \"This is a definition of different protocol version\\n\";\r\n    } break;\r\n\r\n    case NUMBER_OUT_OF_RANGE:\r\n        std::cerr << \"Maybe you should use a 64-bit integer type instead?\\n\";\r\n        break;\r\n\r\n    case TYPE_MISMATCH: {\r\n        const TypeMismatchError& err = static_cast<const TypeMismatchError&>(e);\r\n        std::cout << \"don't you dare use a \" << err.actual_type()\r\n                  << \" to fool me!\\n\";\r\n    } break;\r\n\r\n    case OBJECT_MEMBER: {\r\n        const ObjectMemberError& err = static_cast<const ObjectMemberError&>(e);\r\n        std::cout << \"The member \" << err.member_name() << \" is naughty!\\n\";\r\n    } break;\r\n\r\n    // Many more types of error has been defined, but not shown here for simplicity\r\n    \r\n    default:\r\n        break;\r\n    }\r\n}\r\n```\r\n\r\n## Memory handling and exceptions\r\n\r\nException handling (`throw`, `try`, `catch`) is not used by this library, to accommodate the needs of fake C++ programmers. It is designed, however, to be exception safe by using RAII wrappers to do all resource management. Copy, move constructor/assignment operator are disabled at certain places to avoid ownership mismanagement.\r\n\r\nNotably, the `ParsingResult` class is not copyable. This simplifies the memory handling because it fully owns the error stack. It is movable, however, if you define `AUTOJSONCXX_HAS_RVALUE`. If you ever need to pass it around or store it somewhere, the simpliest way is to use a shared pointer.\r\n\r\n## Type support\r\n\r\nThese types are supported by this library:\r\n\r\n* Basic types: `bool`, `char`, `int`, `unsigned int`, `long long`, `unsigned long long`, `std::string`\r\n* Array tyeps: `std::vector<>`, `std::deque<>`, `std::array<>`, `std::tuple<>` (this one needs special care)\r\n* Nullable types: `std::nullptr_t`, `std::unique_ptr<>`, `std::shared_ptr<>`\r\n* Map types: `std::map<>`, `std::unordered_map<>`, `std::multimap<>`, `std::unordered_multimap<>` (The key must be of string type)\r\n* Object types: any class generated by the script *autojsoncxx.py*.\r\n\r\nNote: `char` is mapped to JSON `Boolean` type, the same as `bool`. This is done so that people can avoid the cariacture that is `std::vector<bool>`. If you need a character type, use an integer type or a single character string instead.\r\n\r\nIf you include `<autojsoncxx/boost_types.hpp>`, you will also get support for\r\n\r\n* Array types: `boost::container::vector<>`, `boost::container::deque<>`, `boost::array`\r\n* Nullable types: `boost::shared_ptr<>`, `boost::optional<>`\r\n* Map types: `boost::unordered_map<>`, `boost::unordered_multimap<>` (The key must be of string type)\r\n\r\n**No raw pointer and reference types are supported. Use smart pointers instead**. They do not convey any information about ownership, and will make correct memory management (especially by a code generator) much more difficult.\r\n\r\n### Complex types\r\n\r\nThe supported types can be arbitrarily nested, for example\r\n\r\n```c++\r\n#define AUTOJSONCXX_MODERN_COMPILER 1 \r\n#include <iostream>\r\n#include \"person.hpp\"\r\n\r\nint main()\r\n{\r\n    auto test = std::make_tuple(std::vector<std::string>{ \"A\", \"BC\", \"DEF\" }, nullptr,\r\n                                3.1415926, -223, std::shared_ptr<int>(),\r\n                                std::map<std::string, bool>{ { \"a\", true }, \r\n                                                           { \"Δ\", false } },\r\n                                std::make_shared<std::array<Person, 2>>());\r\n    \r\n    std::string str;\r\n    \r\n    // This requires true variadic template support \r\n    // MSVC 2012 has std::tuple<>, but it is faked with macros\r\n    // Avoid std::tuple<> if your compiler is not strong enough\r\n    autojsoncxx::to_pretty_json_string(str, test);\r\n    \r\n    std::cout << str << '\\n';\r\n    return 0;\r\n}\r\n```\r\n\r\nSample output\r\n\r\n```javascript\r\n[\r\n    [\r\n        \"A\",\r\n        \"BC\",\r\n        \"DEF\"\r\n    ],\r\n    null,\r\n    3.1415926,\r\n    -223,\r\n    null,\r\n    {\r\n        \"a\": true,\r\n        \"Δ\": false\r\n    },\r\n    [\r\n        {\r\n            \"ID\": 0,\r\n            \"name\": \"anonymous\",\r\n            \"height\": 0.0,\r\n            \"weight\": 0.0,\r\n            \"known_associates\": []\r\n        },\r\n        {\r\n            \"ID\": 0,\r\n            \"name\": \"anonymous\",\r\n            \"height\": 0.0,\r\n            \"weight\": 0.0,\r\n            \"known_associates\": []\r\n        }\r\n    ]\r\n]\r\n```\r\n### Self defined type\r\n\r\nThe core of the library is two template class, `SAXEventHandler` and `Serializer`. The base templates are defined as:\r\n\r\n```c++\r\nnamespace autojsoncxx {\r\n\r\n// The core handlers for parsing\r\ntemplate <class T>\r\nclass SAXEventHandler;\r\n\r\n// Only the second parameter should be specialized\r\ntemplate <class Writer, class T>\r\nstruct Serializer;\r\n\r\n}\r\n```\r\n\r\nEach of the full or partial specialization of these templates will add new type support to the library. \r\n\r\nWriting the handler is somewhat difficult, because there are a multitude of errors that can result from a mismatched JSON. So there is some base classes provided, based on *Curiously Recurring Template Pattern*. For primitive types, such as a simple variant of `int` and `bool`, or string types (`QString`, `CString`, `icu::UnicodeString`, `YetAnotherStringThatIsSoMuchBetterThanTheRest`), derive from `BaseSAXEventHandler`. There are also base classes for array type `VectorBaseSAXEventHandler`, nullable type `NullableBaseSAXEventHandler`, map type `MapBaseSAXEventHandler`. If you implement your own string, you probably want to add map type support as well, because the default implementation is specialized on `std::string`.\r\n\r\nWriting the serializer is very easy, and one can easily figure it out by looking at the source code.\r\n\r\n### About tuple types\r\n\r\nThere are only one tuple type supported `std::tuple` (`boost::tuple` is not supported). Implementing it requires true variadic templates, so for most compilers it is not accessible.\r\n\r\nIf you want to use it, you need to define both `AUTOJSONCXX_HAS_MODERN_TYPES` and `AUTOJSONCXX_HAS_VARIADIC_TEMPLATE` to be nonzero. The macro `AUTOJSONCXX_MODERN_COMPILER` automatically turns on both two.\r\n\r\nThe tuple type is mapped to a JSON array of heterogenous types. So `std::tuple<int, std::string, double>` maps to a JSON array of three element of type `Number`, `String`, and `Number` respectively.\r\n\r\nDuring parsing, only the prefix is matched. That is, if the JSON array is longer than the tuple size, the extraneous part will be silently dropped; if the JSON array is shorter than the tuple size, the not-mapped element simply remains untouched. This design is based on the assumption that when you need a heterogeneous array, you probably prioritize flexibility over strict conformance.\r\n\r\nNote that the matched part still must have compatible type. Support for variant types is planned.\r\n\r\n## C++11 features\r\n\r\nA set of macros control the usage of c++11 features. Define these macros as nonzero constants *before* inclusion, or define it in your build system.\r\n\r\n* `AUTOJSONCXX_MODERN_COMPILER`: turn on all of the below\r\n* `AUTOJSONCXX_HAS_MODERN_TYPES`: add support for c++11 new types, such as `std::shared_ptr<>`.\r\n* `AUTOJSONCXX_HAS_RVALUE`: enable the use of r-value references and move semantic.\r\n* `AUTOJSONCXX_HAS_NOEXCEPT`: enable the use of keyword `noexcept` and the function `std::move_if_noexcept()`.\r\n* `AUTOJSONCXX_HAS_VARIADIC_TEMPLATE`: enable the use of variadic templates. required if `std::tuple<>` is used.\r\n* `AUTOJSONCXX_HAS_EXPLICIT_OPERATOR`: enable the use of `explicit operator bool()`. Otherwise no conversion to bool operator is defined.\r\n\r\nThe 64-bit integer type `long long` and `unsigned long long` is always required. Though not in C++03 standard, most compilers support it nontheless.\r\n\r\n## Encoding\r\n\r\nThe default encoding is `UTF-8`. If you need to read/write JSON in `UTF-16` or `UTF-32`, instantiate the class `SAXEventHandler` and/or `Serializer`, and use it in combination with RapidJSON's transcoding capability.\r\n\r\n## Other\r\n\r\n* You can have multiple definition of classes in the same file, simply by making the root an array of definitions.\r\n* Remember to fully qualify the type names or otherwise they may not be found. If the compiler still errs or warns about the namespaces, prefix it with global namespace scope resolution operator `::`, such as `::utility::event`, `::std::vector<::utility::event>`.\r\n\r\n## To do\r\n\r\n- [x] Automatic <s>unit</s> functional testing of the library\r\n- [ ] Test on C++03 compilers\r\n- [x] Test on Microsoft's C++ compiler\r\n- [ ] Automatic detection of compiler support for c++11 features\r\n- [ ] Full documentation about the API\r\n- [x] Map types support\r\n- [ ] Variant types support\r\n- [ ] Properly format the output of code generator\r\n- [ ] Option to separate the class definition and its helper classes in the output\r\n- [x] Option to check the definition file for potential errors, in order to avoid horrid C++ template compile error\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}